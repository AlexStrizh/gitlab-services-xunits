// @unit-test
Процедура Тест_МетодЗначениеВКоллекцииСуществует(Фреймворк) Экспорт
	
	Эталон = Новый Соответствие();
	Эталон.Вставить("ИмяМетода0", "updates");
	Эталон.Вставить("ИмяМетода", "updates");
	Эталон.Вставить("ИмяМетода1", "updates1");
	Эталон = Новый ФиксированноеСоответствие(Эталон);
	
	Значение = ОбщегоНазначения.ЗначениеВКоллекцииСуществует(Эталон, "ИмяМетода", "updates");
	Фреймворк.ПроверитьИстину(Значение);
	
	Значение = ОбщегоНазначения.ЗначениеВКоллекцииСуществует(Эталон, "ФэйковоеИмя", "updates");
	Фреймворк.ПроверитьЛожь(Значение);

КонецПроцедуры

// @unit-test
Процедура Тест_МетодДополнитьКоллекциюТекстомИзПотока(Фреймворк) Экспорт
	
	Поток = Новый ПотокВПамяти();
	ЗаписьТекста = Новый ЗаписьТекста(Поток);
	Значение = "Туточки текст потока";
	ЗаписьТекста.Записать(Значение);
   	ЗаписьТекста.Закрыть();

	Коллекция = Новый Структура("Ключ1", "Значение1");
	ОбщегоНазначения.ДополнитьКоллекциюТекстомИзПотока(Поток, "Ключ2", Коллекция);
   	Поток.Закрыть();

   	Фреймворк.ПроверитьРавенство( Значение, Коллекция.Ключ2 );

КонецПроцедуры

// @unit-test
Процедура Тест_МетодПреобразоватьПотокВКоллекциюКакJSON(Фреймворк) Экспорт
	
	Поток = Новый ПотокВПамяти();
	ЗаписьТекста = Новый ЗаписьТекста(Поток);
	ЭталонJSON = "{
				 |""Сообщение"": ""ТекстСообщения""
				 |}";
	ЗаписьТекста.Записать(ЭталонJSON);
   	ЗаписьТекста.Закрыть();

	Коллекция1 = Неопределено;
	ОбщегоНазначения.ПреобразоватьПотокВКоллекциюКакJSON(Поток, Истина, Истина, Коллекция1);
	
	Коллекция2 = Неопределено;
	ОбщегоНазначения.ПреобразоватьПотокВКоллекциюКакJSON(Поток, Ложь, Истина, Коллекция2);
	
	Коллекция3 = Неопределено;
	ОбщегоНазначения.ПреобразоватьПотокВКоллекциюКакJSON(Поток, Ложь, Ложь, Коллекция3);

   	Поток.Закрыть();

   	Фреймворк.ПроверитьТип( Коллекция1, "Соответствие" );
   	Фреймворк.ПроверитьТип( Коллекция2, "Структура" );
   	Фреймворк.ПроверитьРавенство( Коллекция1.Получить("json"), ЭталонJSON );
   	Фреймворк.ПроверитьРавенство( Коллекция2.json, ЭталонJSON );
   	Фреймворк.ПроверитьЛожь( Коллекция3.Свойство("json") );
	
КонецПроцедуры

///////////////////////////////

Функция РезультатЗапросаMock(Знач URL, Знач Token, Знач ПутьКТелуЗапроса, Знач КаталогПроекта) Экспорт
	
	ПараметрыСоединения = РазобратьURL(URL);
	АдресСервиса = СтрШаблон("%1/webhook/epf/updates", ПараметрыСоединения.Путь);
	
	HTTPСоединение = Новый HTTPСоединение(ПараметрыСоединения.Сервер);
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/json");
	Заголовки.Вставить("X-Gitlab-Event", "Push Hook");
	Заголовки.Вставить("X-Gitlab-Token", Token);

	HTTPЗапрос = Новый HTTPЗапрос(АдресСервиса, Заголовки);
	
	ПолныйПуть = ПолучитьПолныйПуть(ПутьКТелуЗапроса, КаталогПроекта);
	HTTPЗапрос.УстановитьИмяФайлаТела(ПолныйПуть);
	
	Возврат HTTPСоединение.ОтправитьДляОбработки(HTTPЗапрос);
	
КонецФункции

//Объединяем относительные пути файловой системы в один
// при передаче Путь = ../test/file.txt и ПутьОтносительно=c:\work\ возращаем c:\test\file.txt
// при передаче Путь = ./test/file.txt и ПутьОтносительно=c:\work\ возращаем c:\work\test\file.txt
// если в начале нет точки, считаем этот путь полным. 
Функция ПолучитьПолныйПуть(Знач Путь, Знач ПутьОтносительно) Экспорт
	Перем Результат;
	Результат = Путь;
	Если Лев(СокрЛП(Путь), 1) = "." Тогда 
		ФайлОбработки = Новый Файл(ПутьОтносительно);
		КаталогОбработки = ДополнитьСлешВПуть(ФайлОбработки.ПолноеИмя);
		ФайлПути = Новый Файл(КаталогОбработки + Путь);
		
		Результат = ФайлПути.ПолноеИмя;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ДобавитьОбработчикСобытий(Знач Наименование = "", Знач СекретныйТокен = "") Экспорт
	
		НовыйЭлемент = Справочники.Webhooks.СоздатьЭлемент();
		НовыйЭлемент.Наименование = Наименование;
		НовыйЭлемент.СекретныйТокен = СекретныйТокен;
		НовыйЭлемент.Записать();
		
		Возврат НовыйЭлемент;
	
КонецФункции

#Область СлужебныеПроцедурыИФунции

Функция РазобратьURL(URL)
	Возврат КоннекторHTTP.РазобратьURL(URL);
КонецФункции

// Функция ДополнитьСлешВПуть
//
// Параметры:
// ИмяКаталога
//
// Описание:
// Функция дополняет и возвращает слеш в путь в конец строки, если он отсутствует
//
Функция ДополнитьСлешВПуть(Знач Каталог) Экспорт
	Разделитель = "\";
	
	Если ПустаяСтрока(Каталог) Тогда
		Возврат Каталог;
	КонецЕсли;
	
	Если Прав(Каталог, 1) <> Разделитель Тогда
		Каталог = Каталог + Разделитель;
	КонецЕсли;
	
	Возврат Каталог;
КонецФункции

#КонецОбласти
